import "./chunk-V4OQ3NZ2.js";

// node_modules/@undecaf/zbar-wasm/dist/index.mjs
function t(t2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(i3, o3) {
    function s3(t3) {
      try {
        c3(r2.next(t3));
      } catch (t4) {
        o3(t4);
      }
    }
    function a3(t3) {
      try {
        c3(r2.throw(t3));
      } catch (t4) {
        o3(t4);
      }
    }
    function c3(t3) {
      var e3;
      t3.done ? i3(t3.value) : (e3 = t3.value, e3 instanceof n2 ? e3 : new n2(function(t4) {
        t4(e3);
      })).then(s3, a3);
    }
    c3((r2 = r2.apply(t2, e2 || [])).next());
  });
}
var e;
var n = (e = import.meta.url, async function(t2 = {}) {
  var n2, r2, i3 = t2;
  i3.ready = new Promise((t3, e2) => {
    n2 = t3, r2 = e2;
  });
  var o3, s3, a3, c3 = Object.assign({}, i3), _2 = "object" == typeof window, u2 = "function" == typeof importScripts, A2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, f2 = "";
  if (A2) {
    const { createRequire: t3 } = await Promise.resolve().then(() => g);
    var h2 = t3(import.meta.url), l2 = h2("fs"), R2 = h2("path");
    f2 = u2 ? R2.dirname(f2) + "/" : h2("url").fileURLToPath(new URL("./", import.meta.url)), o3 = (t4, e2) => (t4 = U(t4) ? new URL(t4) : R2.normalize(t4), l2.readFileSync(t4, e2 ? void 0 : "utf8")), a3 = (t4) => {
      var e2 = o3(t4, true);
      return e2.buffer || (e2 = new Uint8Array(e2)), e2;
    }, s3 = (t4, e2, n3, r3 = true) => {
      t4 = U(t4) ? new URL(t4) : R2.normalize(t4), l2.readFile(t4, r3 ? void 0 : "utf8", (t5, i4) => {
        t5 ? n3(t5) : e2(r3 ? i4.buffer : i4);
      });
    }, !i3.thisProgram && process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), i3.inspect = () => "[Emscripten Module object]";
  } else (_2 || u2) && (u2 ? f2 = self.location.href : "undefined" != typeof document && document.currentScript && (f2 = document.currentScript.src), e && (f2 = e), f2 = 0 !== f2.indexOf("blob:") ? f2.substr(0, f2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o3 = (t3) => {
    var e2 = new XMLHttpRequest();
    return e2.open("GET", t3, false), e2.send(null), e2.responseText;
  }, u2 && (a3 = (t3) => {
    var e2 = new XMLHttpRequest();
    return e2.open("GET", t3, false), e2.responseType = "arraybuffer", e2.send(null), new Uint8Array(e2.response);
  }), s3 = (t3, e2, n3) => {
    var r3 = new XMLHttpRequest();
    r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
      200 == r3.status || 0 == r3.status && r3.response ? e2(r3.response) : n3();
    }, r3.onerror = n3, r3.send(null);
  });
  var d2, m3, p2, y = i3.print || console.log.bind(console), B2 = i3.printErr || console.error.bind(console);
  Object.assign(i3, c3), c3 = null, i3.arguments && i3.arguments, i3.thisProgram && i3.thisProgram, i3.quit && i3.quit, i3.wasmBinary && (d2 = i3.wasmBinary), i3.noExitRuntime, "object" != typeof WebAssembly && P("no native wasm support detected");
  var E, I, Z = false;
  function v() {
    var t3 = m3.buffer;
    i3.HEAP8 = new Int8Array(t3), i3.HEAP16 = new Int16Array(t3), i3.HEAP32 = new Int32Array(t3), i3.HEAPU8 = E = new Uint8Array(t3), i3.HEAPU16 = new Uint16Array(t3), i3.HEAPU32 = I = new Uint32Array(t3), i3.HEAPF32 = new Float32Array(t3), i3.HEAPF64 = new Float64Array(t3);
  }
  var b = [], C = [], N = [], S = 0, w = null;
  function P(t3) {
    i3.onAbort && i3.onAbort(t3), B2(t3 = "Aborted(" + t3 + ")"), Z = true, t3 += ". Build with -sASSERTIONS for more info.";
    var e2 = new WebAssembly.RuntimeError(t3);
    throw r2(e2), e2;
  }
  var T, O, D = "data:application/octet-stream;base64,";
  function F(t3) {
    return t3.startsWith(D);
  }
  function U(t3) {
    return t3.startsWith("file://");
  }
  function H(t3) {
    if (t3 == T && d2) return new Uint8Array(d2);
    if (a3) return a3(t3);
    throw "both async and sync fetching of the wasm failed";
  }
  function G(t3, e2, n3) {
    return function(t4) {
      if (!d2 && (_2 || u2)) {
        if ("function" == typeof fetch && !U(t4)) return fetch(t4, { credentials: "same-origin" }).then((e3) => {
          if (!e3.ok) throw "failed to load wasm binary file at '" + t4 + "'";
          return e3.arrayBuffer();
        }).catch(() => H(t4));
        if (s3) return new Promise((e3, n4) => {
          s3(t4, (t5) => e3(new Uint8Array(t5)), n4);
        });
      }
      return Promise.resolve().then(() => H(t4));
    }(t3).then((t4) => WebAssembly.instantiate(t4, e2)).then((t4) => t4).then(n3, (t4) => {
      B2("failed to asynchronously prepare wasm: " + t4), P(t4);
    });
  }
  i3.locateFile ? F(T = "zbar.wasm") || (O = T, T = i3.locateFile ? i3.locateFile(O, f2) : f2 + O) : T = new URL("zbar.wasm", import.meta.url).href;
  var L, M = (t3) => {
    for (; t3.length > 0; ) t3.shift()(i3);
  }, x = (t3) => {
    var e2 = t3 - m3.buffer.byteLength + 65535 >>> 16;
    try {
      return m3.grow(e2), v(), 1;
    } catch (t4) {
    }
  }, W = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, k = [null, [], []], Y = (t3, e2) => {
    var n3 = k[t3];
    0 === e2 || 10 === e2 ? ((1 === t3 ? y : B2)(((t4, e3, n4) => {
      for (var r3 = e3 + n4, i4 = e3; t4[i4] && !(i4 >= r3); ) ++i4;
      if (i4 - e3 > 16 && t4.buffer && W) return W.decode(t4.subarray(e3, i4));
      for (var o4 = ""; e3 < i4; ) {
        var s4 = t4[e3++];
        if (128 & s4) {
          var a4 = 63 & t4[e3++];
          if (192 != (224 & s4)) {
            var c4 = 63 & t4[e3++];
            if ((s4 = 224 == (240 & s4) ? (15 & s4) << 12 | a4 << 6 | c4 : (7 & s4) << 18 | a4 << 12 | c4 << 6 | 63 & t4[e3++]) < 65536) o4 += String.fromCharCode(s4);
            else {
              var _3 = s4 - 65536;
              o4 += String.fromCharCode(55296 | _3 >> 10, 56320 | 1023 & _3);
            }
          } else o4 += String.fromCharCode((31 & s4) << 6 | a4);
        } else o4 += String.fromCharCode(s4);
      }
      return o4;
    })(n3, 0)), n3.length = 0) : n3.push(e2);
  }, j = { d: () => true, e: function() {
    return Date.now();
  }, c: (t3) => {
    var e2 = E.length, n3 = 2147483648;
    if ((t3 >>>= 0) > n3) return false;
    for (var r3, i4, o4 = 1; o4 <= 4; o4 *= 2) {
      var s4 = e2 * (1 + 0.2 / o4);
      s4 = Math.min(s4, t3 + 100663296);
      var a4 = Math.min(n3, (r3 = Math.max(t3, s4)) + ((i4 = 65536) - r3 % i4) % i4);
      if (x(a4)) return true;
    }
    return false;
  }, f: (t3) => 52, b: function(t3, e2, n3, r3, i4) {
    return 70;
  }, a: (t3, e2, n3, r3) => {
    for (var i4 = 0, o4 = 0; o4 < n3; o4++) {
      var s4 = I[e2 >> 2], a4 = I[e2 + 4 >> 2];
      e2 += 8;
      for (var c4 = 0; c4 < a4; c4++) Y(t3, E[s4 + c4]);
      i4 += a4;
    }
    return I[r3 >> 2] = i4, 0;
  } };
  function q() {
    function t3() {
      L || (L = true, i3.calledRun = true, Z || (M(C), n2(i3), i3.onRuntimeInitialized && i3.onRuntimeInitialized(), function() {
        if (i3.postRun) for ("function" == typeof i3.postRun && (i3.postRun = [i3.postRun]); i3.postRun.length; ) t4 = i3.postRun.shift(), N.unshift(t4);
        var t4;
        M(N);
      }()));
    }
    S > 0 || (function() {
      if (i3.preRun) for ("function" == typeof i3.preRun && (i3.preRun = [i3.preRun]); i3.preRun.length; ) t4 = i3.preRun.shift(), b.unshift(t4);
      var t4;
      M(b);
    }(), S > 0 || (i3.setStatus ? (i3.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        i3.setStatus("");
      }, 1), t3();
    }, 1)) : t3()));
  }
  if (function() {
    var t3, e2, n3, o4, s4 = { a: j };
    function a4(t4, e3) {
      var n4, r3 = t4.exports;
      return m3 = (p2 = r3).g, v(), p2.s, n4 = p2.h, C.unshift(n4), function(t5) {
        if (S--, i3.monitorRunDependencies && i3.monitorRunDependencies(S), 0 == S && w) {
          var e4 = w;
          w = null, e4();
        }
      }(), r3;
    }
    if (S++, i3.monitorRunDependencies && i3.monitorRunDependencies(S), i3.instantiateWasm) try {
      return i3.instantiateWasm(s4, a4);
    } catch (t4) {
      B2("Module.instantiateWasm callback failed with error: " + t4), r2(t4);
    }
    (t3 = d2, e2 = T, n3 = s4, o4 = function(t4) {
      a4(t4.instance);
    }, t3 || "function" != typeof WebAssembly.instantiateStreaming || F(e2) || U(e2) || A2 || "function" != typeof fetch ? G(e2, n3, o4) : fetch(e2, { credentials: "same-origin" }).then((t4) => WebAssembly.instantiateStreaming(t4, n3).then(o4, function(t5) {
      return B2("wasm streaming compile failed: " + t5), B2("falling back to ArrayBuffer instantiation"), G(e2, n3, o4);
    }))).catch(r2);
  }(), i3._ImageScanner_create = () => (i3._ImageScanner_create = p2.i)(), i3._ImageScanner_destory = (t3) => (i3._ImageScanner_destory = p2.j)(t3), i3._ImageScanner_set_config = (t3, e2, n3, r3) => (i3._ImageScanner_set_config = p2.k)(t3, e2, n3, r3), i3._ImageScanner_enable_cache = (t3, e2) => (i3._ImageScanner_enable_cache = p2.l)(t3, e2), i3._ImageScanner_recycle_image = (t3, e2) => (i3._ImageScanner_recycle_image = p2.m)(t3, e2), i3._ImageScanner_get_results = (t3) => (i3._ImageScanner_get_results = p2.n)(t3), i3._ImageScanner_scan = (t3, e2) => (i3._ImageScanner_scan = p2.o)(t3, e2), i3._Image_create = (t3, e2, n3, r3, o4, s4) => (i3._Image_create = p2.p)(t3, e2, n3, r3, o4, s4), i3._Image_destory = (t3) => (i3._Image_destory = p2.q)(t3), i3._Image_get_symbols = (t3) => (i3._Image_get_symbols = p2.r)(t3), i3._free = (t3) => (i3._free = p2.t)(t3), i3._malloc = (t3) => (i3._malloc = p2.u)(t3), w = function t3() {
    L || q(), L || (w = t3);
  }, i3.preInit) for ("function" == typeof i3.preInit && (i3.preInit = [i3.preInit]); i3.preInit.length > 0; ) i3.preInit.pop()();
  return q(), t2.ready;
});
var r;
function i(e2 = {}) {
  r = function() {
    return t(this, void 0, void 0, function* () {
      const t2 = yield n(e2);
      if (t2) return t2;
      throw Error("WASM was not loaded");
    });
  }();
}
function o() {
  return t(this, void 0, void 0, function* () {
    return r || i(), yield r;
  });
}
var s;
var a;
var c;
!function(t2) {
  t2[t2.ZBAR_NONE = 0] = "ZBAR_NONE", t2[t2.ZBAR_PARTIAL = 1] = "ZBAR_PARTIAL", t2[t2.ZBAR_EAN2 = 2] = "ZBAR_EAN2", t2[t2.ZBAR_EAN5 = 5] = "ZBAR_EAN5", t2[t2.ZBAR_EAN8 = 8] = "ZBAR_EAN8", t2[t2.ZBAR_UPCE = 9] = "ZBAR_UPCE", t2[t2.ZBAR_ISBN10 = 10] = "ZBAR_ISBN10", t2[t2.ZBAR_UPCA = 12] = "ZBAR_UPCA", t2[t2.ZBAR_EAN13 = 13] = "ZBAR_EAN13", t2[t2.ZBAR_ISBN13 = 14] = "ZBAR_ISBN13", t2[t2.ZBAR_COMPOSITE = 15] = "ZBAR_COMPOSITE", t2[t2.ZBAR_I25 = 25] = "ZBAR_I25", t2[t2.ZBAR_DATABAR = 34] = "ZBAR_DATABAR", t2[t2.ZBAR_DATABAR_EXP = 35] = "ZBAR_DATABAR_EXP", t2[t2.ZBAR_CODABAR = 38] = "ZBAR_CODABAR", t2[t2.ZBAR_CODE39 = 39] = "ZBAR_CODE39", t2[t2.ZBAR_PDF417 = 57] = "ZBAR_PDF417", t2[t2.ZBAR_QRCODE = 64] = "ZBAR_QRCODE", t2[t2.ZBAR_SQCODE = 80] = "ZBAR_SQCODE", t2[t2.ZBAR_CODE93 = 93] = "ZBAR_CODE93", t2[t2.ZBAR_CODE128 = 128] = "ZBAR_CODE128", t2[t2.ZBAR_SYMBOL = 255] = "ZBAR_SYMBOL", t2[t2.ZBAR_ADDON2 = 512] = "ZBAR_ADDON2", t2[t2.ZBAR_ADDON5 = 1280] = "ZBAR_ADDON5", t2[t2.ZBAR_ADDON = 1792] = "ZBAR_ADDON";
}(s || (s = {})), function(t2) {
  t2[t2.ZBAR_CFG_ENABLE = 0] = "ZBAR_CFG_ENABLE", t2[t2.ZBAR_CFG_ADD_CHECK = 1] = "ZBAR_CFG_ADD_CHECK", t2[t2.ZBAR_CFG_EMIT_CHECK = 2] = "ZBAR_CFG_EMIT_CHECK", t2[t2.ZBAR_CFG_ASCII = 3] = "ZBAR_CFG_ASCII", t2[t2.ZBAR_CFG_BINARY = 4] = "ZBAR_CFG_BINARY", t2[t2.ZBAR_CFG_NUM = 5] = "ZBAR_CFG_NUM", t2[t2.ZBAR_CFG_MIN_LEN = 32] = "ZBAR_CFG_MIN_LEN", t2[t2.ZBAR_CFG_MAX_LEN = 33] = "ZBAR_CFG_MAX_LEN", t2[t2.ZBAR_CFG_UNCERTAINTY = 64] = "ZBAR_CFG_UNCERTAINTY", t2[t2.ZBAR_CFG_POSITION = 128] = "ZBAR_CFG_POSITION", t2[t2.ZBAR_CFG_TEST_INVERTED = 129] = "ZBAR_CFG_TEST_INVERTED", t2[t2.ZBAR_CFG_X_DENSITY = 256] = "ZBAR_CFG_X_DENSITY", t2[t2.ZBAR_CFG_Y_DENSITY = 257] = "ZBAR_CFG_Y_DENSITY";
}(a || (a = {})), function(t2) {
  t2[t2.ZBAR_ORIENT_UNKNOWN = -1] = "ZBAR_ORIENT_UNKNOWN", t2[t2.ZBAR_ORIENT_UP = 0] = "ZBAR_ORIENT_UP", t2[t2.ZBAR_ORIENT_RIGHT = 1] = "ZBAR_ORIENT_RIGHT", t2[t2.ZBAR_ORIENT_DOWN = 2] = "ZBAR_ORIENT_DOWN", t2[t2.ZBAR_ORIENT_LEFT = 3] = "ZBAR_ORIENT_LEFT";
}(c || (c = {}));
var _ = class {
  constructor(t2, e2) {
    this.ptr = t2, this.inst = e2;
  }
  checkAlive() {
    if (!this.ptr) throw Error("Call after destroyed");
  }
  getPointer() {
    return this.checkAlive(), this.ptr;
  }
};
var u = class {
  constructor(t2, e2) {
    this.ptr = t2, this.ptr32 = t2 >> 2, this.buf = e2, this.HEAP8 = new Int8Array(e2), this.HEAPU32 = new Uint32Array(e2), this.HEAP32 = new Int32Array(e2);
  }
};
var A = class _A extends u {
  get type() {
    return this.HEAPU32[this.ptr32];
  }
  get data() {
    const t2 = this.HEAPU32[this.ptr32 + 4], e2 = this.HEAPU32[this.ptr32 + 5];
    return Int8Array.from(this.HEAP8.subarray(e2, e2 + t2));
  }
  get points() {
    const t2 = this.HEAPU32[this.ptr32 + 7], e2 = this.HEAPU32[this.ptr32 + 8] >> 2, n2 = [];
    for (let r2 = 0; r2 < t2; ++r2) {
      const t3 = this.HEAP32[e2 + 2 * r2], i3 = this.HEAP32[e2 + 2 * r2 + 1];
      n2.push({ x: t3, y: i3 });
    }
    return n2;
  }
  get orientation() {
    return this.HEAP32[this.ptr32 + 9];
  }
  get next() {
    const t2 = this.HEAPU32[this.ptr32 + 11];
    return t2 ? new _A(t2, this.buf) : null;
  }
  get time() {
    return this.HEAPU32[this.ptr32 + 13];
  }
  get cacheCount() {
    return this.HEAP32[this.ptr32 + 14];
  }
  get quality() {
    return this.HEAP32[this.ptr32 + 15];
  }
};
var f = class extends u {
  get head() {
    const t2 = this.HEAPU32[this.ptr32 + 2];
    return t2 ? new A(t2, this.buf) : null;
  }
};
var h = class _h {
  constructor(t2) {
    this.type = t2.type, this.typeName = s[this.type], this.data = t2.data, this.points = t2.points, this.orientation = t2.orientation, this.time = t2.time, this.cacheCount = t2.cacheCount, this.quality = t2.quality;
  }
  static createSymbolsFromPtr(t2, e2) {
    if (0 == t2) return [];
    let n2 = new f(t2, e2).head;
    const r2 = [];
    for (; null !== n2; ) r2.push(new _h(n2)), n2 = n2.next;
    return r2;
  }
  decode(t2) {
    return new TextDecoder(t2).decode(this.data);
  }
};
var l = class extends _ {
  static createFromGrayBuffer(e2, n2, r2, i3 = 0) {
    return t(this, void 0, void 0, function* () {
      const t2 = yield o(), s3 = new Uint8Array(r2), a3 = e2 * n2;
      if (a3 !== s3.byteLength) throw Error(`data length (${s3.byteLength} bytes) does not match width and height (${a3} bytes)`);
      const c3 = t2._malloc(a3);
      t2.HEAPU8.set(s3, c3);
      return new this(t2._Image_create(e2, n2, 808466521, c3, a3, i3), t2);
    });
  }
  static createFromRGBABuffer(e2, n2, r2, i3 = 0) {
    return t(this, void 0, void 0, function* () {
      const t2 = yield o(), s3 = new Uint8Array(r2), a3 = e2 * n2;
      if (4 * a3 !== s3.byteLength) throw Error(`data length (${s3.byteLength} bytes) does not match width and height (${4 * a3} bytes)`);
      const c3 = t2._malloc(a3), _2 = c3 + a3, u2 = t2.HEAPU8;
      for (let t3 = c3, e3 = 0; t3 < _2; t3++, e3 += 4) u2[t3] = 19595 * s3[e3] + 38469 * s3[e3 + 1] + 7472 * s3[e3 + 2] >> 16;
      return new this(t2._Image_create(e2, n2, 808466521, c3, a3, i3), t2);
    });
  }
  destroy() {
    this.checkAlive(), this.inst._Image_destory(this.ptr), this.ptr = 0;
  }
  getSymbols() {
    this.checkAlive();
    const t2 = this.inst._Image_get_symbols(this.ptr);
    return h.createSymbolsFromPtr(t2, this.inst.HEAPU8.buffer);
  }
};
var R = class extends _ {
  static create() {
    return t(this, void 0, void 0, function* () {
      const t2 = yield o();
      return new this(t2._ImageScanner_create(), t2);
    });
  }
  destroy() {
    this.checkAlive(), this.inst._ImageScanner_destory(this.ptr), this.ptr = 0;
  }
  setConfig(t2, e2, n2) {
    return this.checkAlive(), this.inst._ImageScanner_set_config(this.ptr, t2, e2, n2);
  }
  enableCache(t2 = true) {
    this.checkAlive(), this.inst._ImageScanner_enable_cache(this.ptr, t2);
  }
  recycleImage(t2) {
    this.checkAlive(), this.inst._ImageScanner_recycle_image(this.ptr, t2.getPointer());
  }
  getResults() {
    this.checkAlive();
    const t2 = this.inst._ImageScanner_get_results(this.ptr);
    return h.createSymbolsFromPtr(t2, this.inst.HEAPU8.buffer);
  }
  scan(t2) {
    return this.checkAlive(), this.inst._ImageScanner_scan(this.ptr, t2.getPointer());
  }
};
var d = () => t(void 0, void 0, void 0, function* () {
  const t2 = yield R.create();
  return t2.setConfig(s.ZBAR_NONE, a.ZBAR_CFG_BINARY, 1), t2;
});
var m;
var p = (e2, n2) => t(void 0, void 0, void 0, function* () {
  void 0 === n2 && (n2 = m || (yield d()), m = n2);
  const t2 = n2.scan(e2);
  if (t2 < 0) throw Error("Scan Failed");
  return 0 === t2 ? [] : e2.getSymbols();
});
var B = (e2, n2, r2, i3) => t(void 0, void 0, void 0, function* () {
  const t2 = yield l.createFromRGBABuffer(n2, r2, e2), o3 = yield p(t2, i3);
  return t2.destroy(), o3;
});
var g = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@preflower/barcode-detector-polyfill/dist/main.js
function a2(e2, t2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(a3, i3) {
    function s3(e3) {
      try {
        c3(r2.next(e3));
      } catch (e4) {
        i3(e4);
      }
    }
    function o3(e3) {
      try {
        c3(r2.throw(e3));
      } catch (e4) {
        i3(e4);
      }
    }
    function c3(e3) {
      var t3;
      e3.done ? a3(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
        e4(t3);
      })).then(s3, o3);
    }
    c3((r2 = r2.apply(e2, t2 || [])).next());
  });
}
var i2 = class _i {
  constructor(e2, n2 = a.ZBAR_CFG_ENABLE, r2 = 1) {
    this.symbolType = e2, this.configType = n2, this.number = r2, this.configSteps = [this];
  }
  static register(e2, t2, n2 = t2.symbolType) {
    return _i.formatsToConfigs[e2] = t2, _i.typesToFormats[n2] = _i.typesToFormats[n2] || e2, t2;
  }
  static formats() {
    return Object.keys(_i.formatsToConfigs);
  }
  static toFormat(e2) {
    return _i.typesToFormats[e2];
  }
  static configure(e2, t2) {
    var n2;
    null === (n2 = _i.formatsToConfigs[t2]) || void 0 === n2 || n2.configSteps.forEach((t3) => e2.setConfig(t3.symbolType, t3.configType, t3.number));
  }
  add(e2) {
    return this.configSteps.push(e2), this;
  }
};
var s2;
i2.formatsToConfigs = {}, i2.typesToFormats = {}, i2.register("codabar", new i2(s.ZBAR_CODABAR)), i2.register("code_39", new i2(s.ZBAR_CODE39)), i2.register("code_93", new i2(s.ZBAR_CODE93)), i2.register("code_128", new i2(s.ZBAR_CODE128)), i2.register("databar", new i2(s.ZBAR_DATABAR)), i2.register("databar_exp", new i2(s.ZBAR_DATABAR_EXP)), i2.register("ean_2", new i2(s.ZBAR_EAN2)), i2.register("ean_5", new i2(s.ZBAR_EAN5)), i2.register("ean_8", new i2(s.ZBAR_EAN8)), i2.register("ean_13", new i2(s.ZBAR_EAN13)), i2.register("ean_13+2", new i2(s.ZBAR_EAN13)).add(new i2(s.ZBAR_EAN2)), i2.register("ean_13+5", new i2(s.ZBAR_EAN13)).add(new i2(s.ZBAR_EAN5)), i2.register("isbn_10", new i2(s.ZBAR_ISBN10)).add(new i2(s.ZBAR_EAN13)), i2.register("isbn_13", new i2(s.ZBAR_ISBN13)).add(new i2(s.ZBAR_EAN13)), i2.register("isbn_13+2", new i2(s.ZBAR_ISBN13)).add(new i2(s.ZBAR_EAN13)).add(new i2(s.ZBAR_EAN2)), i2.register("isbn_13+5", new i2(s.ZBAR_ISBN13)).add(new i2(s.ZBAR_EAN13)).add(new i2(s.ZBAR_EAN5)), i2.register("itf", new i2(s.ZBAR_I25)), i2.register("qr_code", new i2(s.ZBAR_QRCODE)), i2.register("sq_code", new i2(s.ZBAR_SQCODE)), i2.register("upc_a", new i2(s.ZBAR_UPCA)).add(new i2(s.ZBAR_EAN13)), i2.register("upc_e", new i2(s.ZBAR_UPCE)).add(new i2(s.ZBAR_EAN13)), function(e2) {
  e2[e2.UNKNOWN = -1] = "UNKNOWN", e2[e2.UPRIGHT = 0] = "UPRIGHT", e2[e2.ROTATED_RIGHT = 1] = "ROTATED_RIGHT", e2[e2.UPSIDE_DOWN = 2] = "UPSIDE_DOWN", e2[e2.ROTATED_LEFT = 3] = "ROTATED_LEFT";
}(s2 || (s2 = {}));
var o2 = class {
};
var c2 = (() => {
  try {
    return new OffscreenCanvas(1, 1).getContext("2d") instanceof OffscreenCanvasRenderingContext2D;
  } catch (e2) {
    return false;
  }
})();
var m2 = class _m {
  constructor(e2 = {}) {
    if (void 0 !== e2.formats) {
      if (!Array.isArray(e2.formats) || !e2.formats.length) throw new TypeError(`Barcode formats should be a non-empty array of strings but are: ${JSON.stringify(e2)}`);
      const t2 = e2.formats.filter((e3) => !i2.formats().includes(e3));
      if (t2.length) throw new TypeError(`Unsupported barcode format(s): ${t2.join(", ")}`);
    }
    this.formats = e2.formats || i2.formats(), this.zbarConfig = e2.zbar || new o2();
  }
  static getSupportedFormats() {
    return Promise.resolve(i2.formats());
  }
  detect(e2) {
    if (!_m.isImageBitmapSource(e2)) throw new TypeError("BarcodeDetector.detect() argument is not an ImageBitmapSource");
    const t2 = _m.intrinsicDimensions(e2);
    if (0 === t2.width || 0 === t2.height) return Promise.resolve([]);
    try {
      return Promise.all([this.toImageData(e2), this.getScanner()]).then((e3) => {
        const t3 = e3[0], r2 = e3[1];
        return void 0 !== this.zbarConfig.enableCache && r2.enableCache(this.zbarConfig.enableCache), B(t3.data, t3.width, t3.height, r2);
      }).then((e3) => e3.map((e4) => this.toBarcodeDetectorResult(e4)));
    } catch (e3) {
      return Promise.reject(e3);
    }
  }
  getScanner() {
    return new Promise((n2, s3) => a2(this, void 0, void 0, function* () {
      if (!this.scanner) {
        const n3 = yield d();
        this.formats.length > 0 && (n3.setConfig(s.ZBAR_NONE, a.ZBAR_CFG_ENABLE, 0), this.formats.forEach((e2) => i2.configure(n3, e2))), this.scanner = n3;
      }
      n2(this.scanner);
    }));
  }
  toImageData(e2) {
    const t2 = (e3) => {
      const t3 = _m.intrinsicDimensions(e3);
      this.canvas && this.canvas.width === t3.width && this.canvas.height === t3.height || (this.canvas = function(e4, t4) {
        if (c2) return new OffscreenCanvas(e4, t4);
        {
          const n3 = document.createElement("canvas");
          return n3.width = e4, n3.height = t4, n3;
        }
      }(t3.width, t3.height));
      const n2 = this.canvas, r2 = n2.getContext("2d");
      return r2.drawImage(e3, 0, 0), r2.getImageData(0, 0, n2.width, n2.height);
    };
    if (e2 instanceof ImageData) return Promise.resolve(e2);
    if (e2 instanceof Blob) {
      const n2 = document.createElement("img");
      return n2.src = URL.createObjectURL(e2), n2.decode().then(() => t2(n2)).finally(() => URL.revokeObjectURL(n2.src));
    }
    return e2 instanceof CanvasRenderingContext2D ? Promise.resolve(e2.getImageData(0, 0, e2.canvas.width, e2.canvas.height)) : Promise.resolve(t2(e2));
  }
  toBarcodeDetectorResult(e2) {
    const t2 = { minX: 1 / 0, maxX: -1 / 0, minY: 1 / 0, maxY: -1 / 0 };
    e2.points.forEach((e3) => {
      t2.minX = Math.min(t2.minX, e3.x), t2.maxX = Math.max(t2.maxX, e3.x), t2.minY = Math.min(t2.minY, e3.y), t2.maxY = Math.max(t2.maxY, e3.y);
    });
    return { format: i2.toFormat(e2.type), rawValue: e2.decode(this.zbarConfig.encoding), orientation: e2.orientation, quality: e2.quality, boundingBox: DOMRectReadOnly.fromRect({ x: t2.minX, y: t2.minY, width: t2.maxX - t2.minX, height: t2.maxY - t2.minY }), cornerPoints: [{ x: t2.minX, y: t2.minY }, { x: t2.maxX, y: t2.minY }, { x: t2.maxX, y: t2.maxY }, { x: t2.minX, y: t2.maxY }] };
  }
  static isImageBitmapSource(e2) {
    return "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && e2 instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof CanvasRenderingContext2D && e2 instanceof CanvasRenderingContext2D || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap || e2 instanceof ImageData || e2 instanceof Blob || e2 && 0 == e2.width || e2 && 0 == e2.height;
  }
  static intrinsicDimensions(e2) {
    return { width: Number(e2.naturalWidth || e2.videoWidth || e2.width), height: Number(e2.naturalHeight || e2.videoHeight || e2.height) };
  }
};

// node_modules/react-barcode-scanner/esm/polyfill.js
if (typeof window !== "undefined") {
  try {
    window.BarcodeDetector.getSupportedFormats();
  } catch (_a) {
    window.BarcodeDetector = m2;
  }
}
/*! Bundled license information:

@preflower/barcode-detector-polyfill/dist/main.js:
  (*!
   * @preflower/barcode-detector-polyfill v0.9.21
   * A WebAssembly polyfill for the Barcode Detection API
   * Built 2024-11-29T04:04:31.263Z
   * (c) 2021-present Ferdinand Kasper <fkasper@modus-operandi.at>
   * Released under the MIT license.
   * 
   * This work uses https://github.com/undecaf/zbar-wasm.git as per
   * LGPL-2.1 section 6 (https://opensource.org/licenses/LGPL-2.1).
   *)
*/
//# sourceMappingURL=react-barcode-scanner_polyfill.js.map
